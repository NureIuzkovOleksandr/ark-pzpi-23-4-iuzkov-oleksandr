Харківський національний університет радіоелектроніки
Факультет комп’ютерних наук
Катедра програмної інженерії


Звіт
з практичної роботи № 2
з дисципліни «Аналіз та рефакторинг коду»
на тему «Застосування методів рефакторингу Extract Method, Rename Method та Replace Conditional with Polymorphism у мові R»



    Виконав:                                                                           Перевірив:
ст. гр. ПЗПІ-23-4                                                              ст. викладач кафедри ПІ
Юзков Олександр                                            	         Сокорчук Ігор Петрович



Харків 2025
1 ІСТОРІЯ ЗМІН

№ДатаВерсія звітуОпис змін та виправлень106.12.20250.1Зроблено звіт
2 ЗАВДАННЯ
     Метою даної практичної роботи є закріплення навичок аналізу та покращення програмного коду шляхом застосування класичних методів рефакторингу, описаних Мартіном Фаулером. Основна увага приділяється роботі з кодом на мові R, який часто використовується для аналізу даних та статистичних обчислень. У ході виконання роботи було обрано три методи рефакторингу: Extract Method, Rename Method та Replace Conditional with Polymorphism.
3 ОПИС ВИКОНАНОЇ РОБОТИ
     Рефакторинг є важливим інструментом підтримки якості програмного забезпечення протягом усього життєвого циклу проєкту. Особливо актуальним він є для мови R, яка широко використовується у сфері аналізу даних, статистики та наукових досліджень. У таких проєктах код часто створюється поступово, швидко розширюється та з часом може втрачати чітку структуру.
     Поширеними проблемами R-коду є надмірно довгі функції, дублювання обчислень, складні умовні конструкції та неінформативні назви функцій і змінних. Це ускладнює розуміння програм, їх тестування та подальший розвиток. Рефакторинг дозволяє впорядкувати код, зменшити технічний борг та зробити програму більш стійкою до змін.
     3.1 Метод Extract Method
     Під час роботи з мовою програмування R, особливо у задачах аналізу даних, студенти часто прагнуть реалізувати всю необхідну логіку в межах однієї функції. Такий підхід здається зручним на початковому етапі розробки, однак із часом призводить до появи надто великих і перевантажених функцій. У межах однієї функції можуть поєднуватися зчитування даних, їх фільтрація, виконання обчислень, а також формування та вивід результатів.
     Подібна концентрація різнорідної логіки негативно впливає на якість коду, оскільки ускладнює його сприйняття, тестування та подальшу модифікацію. Будь-які зміни або доповнення вимагають аналізу всієї функції, що підвищує ризик помилок.
Проблеми початкового коду:
* одна функція виконує одразу кілька логічно незалежних завдань;
* частини коду неможливо повторно використати без копіювання;
* будь-яка зміна потребує редагування великого блоку коду;
* знижується загальна читабельність і зрозумілість програми.
Код до рефакторингу:
1. analyze_sales <- function(data) {
2.   filtered <- data[data$price > 100, ]
3.   
4.   total <- 0
5.   for (i in 1:nrow(filtered)) {
6.     total <- total + filtered$price[i]
7.   }
8.   
9.   average <- total / nrow(filtered)
10.   
11.   cat("Total sales:", total, "\n")
12.   cat("Average price:", average, "\n")
13. }

   У наведеному фрагменті коду в межах однієї функції одночасно виконуються такі операції:
* фільтрація вхідного набору даних;
* ручний підрахунок загальної суми значень;
* обчислення середнього арифметичного;
* форматований вивід результатів у консоль.
   Поєднання цих дій ускладнює розуміння логіки функції та порушує принцип єдиної відповідальності.
     Метод Extract Method дозволяє розв’язати цю проблему шляхом винесення окремих частин логіки в самостійні функції. У контексті мови R цей підхід є особливо доцільним, оскільки функції легко комбінуються між собою та можуть використовуватися повторно в різних частинах програми.
Код після рефакторингу:
1. filter_expensive_sales <- function(data) {
2.   data[data$price > 100, ]
3. }
4. 
5. calculate_total <- function(values) {
6.   sum(values)
7. }
8. 
9. calculate_average <- function(values) {
10.   mean(values)
11. }
12. 
13. analyze_sales <- function(data) {
14.   filtered <- filter_expensive_sales(data)
15.   
16.   total <- calculate_total(filtered$price)
17.   average <- calculate_average(filtered$price)
18.   
19.   cat("Total sales:", total, "\n")
20.   cat("Average price:", average, "\n")
21. }

     Після рефакторингу основна функція analyze_sales описує лише загальний сценарій обробки даних, тоді як деталі реалізації винесені в окремі допоміжні функції.
Переваги після рефакторингу:
* кожна функція має одну чітко визначену відповідальність;
* код став значно зрозумілішим навіть без додаткових коментарів;
* логіку підрахунків можна легко використовувати в інших частинах проєкту;
* зміни в одному алгоритмі не впливають на інші частини системи;
* покращено підтримуваність та масштабованість коду.
     3.2 Метод Rename Method
     Під час швидкого написання коду, особливо у навчальних або експериментальних проєктах, розробники часто використовують короткі та узагальнені імена функцій і параметрів. Хоча такий код є синтаксично коректним і працює без помилок, він втрачає свою зрозумілість і стає складним для читання.
     З часом або при передачі коду іншому розробнику виникає необхідність витрачати додатковий час на аналіз логіки лише для того, щоб зрозуміти призначення функції та її параметрів.
Код до рефакторингу:
1. calc <- function(a, b, c) {
2.   if (b > c) {
3.     a * 0.8
4.   } else {
5.     a * 0.95
6.   }
7. }
З наведеного прикладу неможливо одразу визначити:
* що саме означає змінна a;
* яку роль відіграють параметри b та c;
* у якому бізнес-контексті використовується ця функція;
* за яким принципом обирається коефіцієнт знижки.
Метод Rename Method спрямований на усунення подібних проблем шляхом надання функціям і параметрам інформативних назв. Завдяки цьому код стає самопояснювальним і значно легшим для сприйняття.
Код після рефакторингу:
1. calculate_discounted_price <- function(price, order_count, discount_threshold) {
2.   if (order_count > discount_threshold) {
3.     price * 0.8
4.   } else {
5.     price * 0.95
6.   }
Після перейменування вже з назви функції та її параметрів зрозуміло, що відбувається обчислення ціни з урахуванням знижки залежно від кількості замовлень.
Переваги після рефакторингу:
* призначення функції зрозуміле без аналізу її реалізації;
* аргументи чітко відображають свою роль у розрахунках;
* код легше використовувати повторно в інших частинах програми;
* зменшується ймовірність помилкового або некоректного використання функції;
* підвищується відповідність принципам чистого коду.
3.3 Метод Replace Conditional with Polymorphism
     У мові R досить поширеною практикою є використання складних умовних конструкцій для вибору різної поведінки програми залежно від типу даних, ролі користувача або іншого параметра. На початкових етапах такі рішення виглядають простими, однак з розширенням функціональності кількість умов зростає, а код стає громіздким і важким для підтримки.
Код до рефакторингу:
1. calculate_tax <- function(type, income) {
2.   if (type == "student") {
3.     income * 0.05
4.   } else if (type == "employee") {
5.     income * 0.18
6.   } else if (type == "business") {
7.     income * 0.25
8.   } else {
9.     stop("Unknown taxpayer type")
10.   }
11. }

Основні недоліки такого підходу:
* складно додавати нові типи платників податків;
* кожна зміна в логіці вимагає редагування центральної функції;
* порушується принцип відкритості/закритості;
* зростає ризик помилок при модифікації умов.
   У мові R природним механізмом реалізації поліморфізму є S3-методи, які дозволяють визначати різну поведінку функції залежно від класу об’єкта без використання умовних операторів.
Код після рефакторингу:
1. calculate_tax <- function(person, income) {
2.   UseMethod("calculate_tax")
3. }
4. 
5. calculate_tax.student <- function(person, income) {
6.   income * 0.05
7. }
8. 
9. calculate_tax.employee <- function(person, income) {
10.   income * 0.18
11. }
12. 
13. calculate_tax.business <- function(person, income) {
14.   income * 0.25
15. }
   У такій реалізації логіка обчислення податку розподілена між окремими методами, кожен з яких відповідає за конкретний тип платника.
Переваги після рефакторингу:
* повністю усунено умовні конструкції;
* легко додавати нові категорії платників без зміни існуючого коду;
* код відповідає принципу відкритості/закритості;
* логіка стає більш структурованою та зрозумілою;
* підвищується тестованість та масштабованість рішення.

4 ВИСНОВКИ
     Після виконання рефакторингу програмний код став більш структурованим та зрозумілим для аналізу. Завдяки виділенню окремих допоміжних функцій, уточненню назв методів і використанню поліморфізму замість умовних операторів основна логіка програми стала наочнішою та легшою для сприйняття, без перевантаження другорядними деталями. Це спрощує навігацію по коду та дозволяє швидше розібратися у послідовності виконання операцій.
     У результаті застосованих змін покращилися читабельність, зручність супроводу, можливість повторного використання та тестування коду, при цьому функціональність і поведінка програми залишилися незмінними.
     
5 ВИКОРИСТАНІ ДЖЕРЕЛА



















ДОДАТОК А
Відеозапис
Відеозапис презентації результатів практичної роботи: https://www.youtube.com/watch?v=wH9Pw2ieUG8
Хронологічний опис відеозапису:
00:10 - Вступ
00:45 – Мета рефакторингу
01:10 - Основні методи рефакторингу
01:42 - Метод Extract Method
02:57 - Метод Rename Method
03:29 - Replace Conditional with Polymorphism
04:34 - Покрокова демонстрація рефакторингу
04:52 - Інструменти для рефакторингу
05:13 – Висновки










ДОДАТОК Б
Слайди презентації

Рисунок Б.1 - Титульний лист

Рисунок Б.2 - Вступ

Рисунок Б.3 – Мета рефакторингу


Рисунок Б.4 – Основні методи рефакторінгу


Рисунок Б.5 – Метод Extract Method
 


Рисунок Б.6 – Extract Method — код до рефакторингу


Рисунок Б.7 – Extract Method — код після рефакторингу


Рисунок Б.8 – Метод Rename Method


Рисунок Б.9 – Rename Method — код до і після


Рисунок Б.10 – Replace Conditional with Polymorphism


Рисунок Б.11 – Умовна логіка — код до рефакторингу


Рисунок Б.12 – Поліморфізм — код після рефакторингу

Рисунок Б.13 – Покрокова демонстрація рефакторингу


Рисунок Б.14 – Інструменти для рефакторингу


Рисунок Б.15 – Висновки


Рисунок Б.16 – Список використаних джерел



ДОДАТОК В
Програмний код
GitHub репозиторій: https://github.com/NureIuzkovOleksandr/ark-pzpi-23-4-iuzkov-oleksandr/blob/main/Pract2/ark-pzpi-23-4-iuzkov-oleksandr-pract2/code-examples-refactoring-methods.r
1. #МЕТОД EXTRACT METHOD
2. #До рефакторингу
3. analyze_sales <- function(data) {
4.   filtered <- data[data$price > 100, ]
5.   
6.   total <- 0
7.   for (i in 1:nrow(filtered)) {
8.     total <- total + filtered$price[i]
9.   }
10.   
11.   average <- total / nrow(filtered)
12.   
13.   cat("Total sales:", total, "\n")
14.   cat("Average price:", average, "\n")
15. }
16. 
17. #Після рефакторингу
18. filter_expensive_sales <- function(data) {
19.   data[data$price > 100, ]
20. }
21. 
22. calculate_total <- function(values) {
23.   sum(values)
24. }
25. 
26. calculate_average <- function(values) {
27.   mean(values)
28. }
29. 
30. analyze_sales <- function(data) {
31.   filtered <- filter_expensive_sales(data)
32.   
33.   total <- calculate_total(filtered$price)
34.   average <- calculate_average(filtered$price)
35.   
36.   cat("Total sales:", total, "\n")
37.   cat("Average price:", average, "\n")
38. }
39. #МЕТОД RENAME METHOD
40. #До рефакторингу
41. calc <- function(a, b, c) {
42.   if (b > c) {
43.     a * 0.8
44.   } else {
45.     a * 0.95
46.   }
47. }
48. #Після рефакторингу
49. calculate_discounted_price <- function(price, order_count, discount_threshold) {
50.   if (order_count > discount_threshold) {
51.     price * 0.8
52.   } else {
53.     price * 0.95
54.   }
55. }
56. #МЕТОД REPLACE CONDITIONAL WITH POLYMORPHISM
57. #До рефакторингу
58. calculate_tax <- function(type, income) {
59.   if (type == "student") {
60.     income * 0.05
61.   } else if (type == "employee") {
62.     income * 0.18
63.   } else if (type == "business") {
64.     income * 0.25
65.   } else {
66.     stop("Unknown taxpayer type")
67.   }
68. }
69. #Після рефакторингу
70. calculate_tax <- function(person, income) {
71.   UseMethod("calculate_tax")
72. }
73. 
74. calculate_tax.student <- function(person, income) {
75.   income * 0.05
76. }
77. 
78. calculate_tax.employee <- function(person, income) {
79.   income * 0.18
80. }
81. 
82. calculate_tax.business <- function(person, income) {
83.   income * 0.25
84. }
85. 
86. 


2










